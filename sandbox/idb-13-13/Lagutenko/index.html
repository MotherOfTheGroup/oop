<!DOCTYPE html>
<html>
	<head> 
		<title>Лагутенко</title>
		<link rel="stylesheet" type="text/css" href="style.css" >
	</head>
<body>
	<h1 align="center">Тег FORM</h1>
	<h3 align="center">Создание формы с кнопкой, на которую нельзя нажать, если не будут заполнены все поля</h3>
	
	<p align="right"> <i>Лагутенко Дмитрий, ИДБ-13-13</i></p>
	
	
	
	<h2>Задачи:</h2>
<ol>
	<li>Разработать форму с кнопкой, используя тег "button".</li>
 		<ul>
     <li>В форме реализовать поля для ввода текста;</li>
     <li>Кнопка не должна быть активна, пока не заполнены все поля формы;</li>
     <li>Дополнить вывод введенных данных для проверки;</li>
    </ul>
	<li>Дать описание UML.</li>
		<ul>
	</ul>
</ol>

<h1 align="center">Задача №1</h1>

<h3>Спецификация </h3>
  <table class="standart">
    <tr>
      <td class="h">HTML:</td>
      <td class="no">3.2</td>
      <td class="yes">4.01</td>
      <td class="yes">5.0</td>
      <td class="xh">XHTML:</td>
      <td class="yes">1.0</td>
      <td class="yes">1.1</td>
    </tr>
  </table>
  <h3>Описание</h3>
  <p> Тег <span class="tag">&lt;form&gt;</span> устанавливает форму на веб-странице. 
    Форма предназначена для обмена данными между пользователем и сервером. Область 
    применения форм не ограничена отправкой данных на сервер, с помощью клиентских 
    скриптов можно получить доступ к любому элементу формы, изменять его и применять 
  по своему усмотрению. </p>
  <p>Документ может содержать любое количество форм, но одновременно на сервер может 
    быть отправлена только одна форма. По этой причине данные форм должны быть независимы 
    друг от друга.</p>
  <p>Для отправки формы на сервер используется кнопка Submit, того же можно 
    добиться, если нажать клавишу <span class="button">Enter</span> в пределах формы. Если кнопка Submit 
    отсутствует в форме, клавиша <span class="button">Enter</span> имитирует ее использование.</p>
  <p>Когда форма отправляется на сервер, управление данными передается программе, 
    заданной атрибутом <span class="attribute">action</span> тега <span class="tag">&lt;form&gt;</span>. 
    Предварительно браузер подготавливает информацию в виде пары &laquo;имя=значение&raquo;, 
    где имя определяется атрибутом <span class="attribute">name</span> тега <span class="tag">&lt;input&gt;</span>, 
    а значение введено пользователем или установлено в поле формы по умолчанию. 
    Если для отправки данных используется метод <span class="value">GET</span>, 
    то адресная строка может принимать следующий вид.</p>
  <p class="example">http://www.htmlbook.ru/cgi-bin/handler.cgi?nick=%C2%E0%ED%FF+%D8%E0%EF%EE%F7%EA%E8%ED&amp;page=5</p>
  <p>Параметры перечисляются после вопросительного знака, указанного после адреса 
    CGI-программы и разделяются между собой символом амперсанда (&amp;). Нелатинские 
    символы преобразуются в шестнадцатеричное представление (в форме %HH, где HH 
    &#8212; шестнадцатеричный код для значения ASCII-символа), пробел заменяется 
    на плюс (+).</p>
  <p>Допускается внутрь контейнера <span class="tag">&lt;form&gt;</span> помещать другие теги, при этом сама форма никак не отображается на веб-странице, видны только ее элементы и результаты вложенных тегов.</p>
  <h3>Синтаксис</h3>

<pre><code class="no-buttons">&lt;form action=&quot;URL&quot;&gt;
  ...
&lt;/form&gt;</code></pre>
  <h3>Атрибуты</h3>
  <dl class="param">
    <dt><a href="http://htmlbook.ru/html/form/accept-charset">accept-charset</a></dt><br>
    <dd>Устанавливает кодировку, в которой сервер может принимать и обрабатывать данные.</dd>
    <dt><a href="http://htmlbook.ru/html/form/action">action</a></dt>
    <dd>Адрес программы или документа, который обрабатывает данные формы. </dd>
    <dt><a href="http://htmlbook.ru/html/form/autocomplete">autocomplete</a></dt>
    <dd>Включает автозаполнение полей формы.</dd>
    <dt><a href="http://htmlbook.ru/html/form/enctype">enctype</a></dt>
    <dd>Способ кодирования данных формы.</dd>
    <dt><a href="http://htmlbook.ru/html/form/method">method</a></dt>
    <dd>Метод протокола HTTP.</dd>
    <dt><a href="http://htmlbook.ru/html/form/name">name</a></dt>
    <dd>Имя формы.</dd>
    <dt><a href="http://htmlbook.ru/html/form/novalidate">novalidate</a></dt>
    <dd>Отменяет встроенную проверку данных формы на корректность ввода.</dd>
    <dt><a href="http://htmlbook.ru/html/form/target">target</a></dt>
    <dd>Имя окна или фрейма, куда обработчик будет загружать возвращаемый результат.</dd>
  </dl>
<p class="more">Также для этого тега доступны <a href="http://htmlbook.ru/html/attr/common">универсальные атрибуты</a> и <a href="http://htmlbook.ru/html/attr/event">события</a>.</p>

  <h3>Закрывающий тег</h3>
  <p> Обязателен.</p>
<h2>Пример</h2>
  

<form name=mainForm>
   <table width="100%" cellspacing="0" cellpadding="4">
    <tr> 
     <td align="right" width="100">Ваше имя</td>
     <td><input type="text" onkeyup=changeButtonStatus() onchange=changeButtonStatus() name=name></td>
    </tr>
    <tr> 
     <td align="right" width="110">Ваша фамилия</td>
     <td><input type="text" onkeyup=changeButtonStatus() onchange=changeButtonStatus() name=surname></td>
    </tr>
    <tr> 
     <td align="right" valign="top">Ваш телефон</td>
     <td><input type="text" onkeyup=changeButtonStatus() onchange=changeButtonStatus() name=phone></td>
    </tr>
	<tr>
     <td align="right" valign="dop">Адрес места жительства</td>
	 <td><input type="text" onkeyup=changeButtonStatus() onchange=changeButtonStatus() name=address></td>
	</tr>
     <td><input type=button onclick="alert('Ваша информация не отправлена на сервер, потому что сервера нет!')" value="Отправить" name=send></td>
   </table>
  </form>

  
<script language="JavaScript"> 
var f=document.mainForm; 
function changeButtonStatus(){ 
f.send.disabled=(f.name.value && f.surname.value && f.phone.value && f.address.value) ? false : true; 
} 
changeButtonStatus(); 
</script>

	<h4>Код примера:</h4>
	<pre><code class="no-buttons">
<table border="4" bgcolor="dda0dd">
<tr>
<td><b>
&lt;form name=mainForm&gt;
   &lt;table width="100%" cellspacing="0" cellpadding="4"&gt;
    &lt;tr&gt; 
	&lt;td align="right" width="100"&gt;Ваше имя&lt;/td&gt;
	 &lt;td&gt;&lt;input type="text" onkeyup=changeButtonStatus() onchange=changeButtonStatus() name=name&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt; 
	&lt;td align="right" width="110"&gt;Ваша фамилия&lt;/td&gt;
	 &lt;td&gt;&lt;input type="text" onkeyup=changeButtonStatus() onchange=changeButtonStatus() name=surname&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt; 
	&lt;td align="right" valign="top"&gt;Ваш телефон&lt;/td&gt;
	 &lt;td&gt;&lt;input type="text" onkeyup=changeButtonStatus() onchange=changeButtonStatus() name=phone&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
	&lt;td align="right" valign="dop"&gt;Адрес места жительства&lt;/td&gt;
	 &lt;td&gt;&lt;input type="text" onkeyup=changeButtonStatus() onchange=changeButtonStatus() name=address&gt;&lt;/td&gt;
	&lt;/tr&gt;
     &lt;td&gt;&lt;input type=button onclick="alert('Ваша информация не отправлена на сервер, потому что сервера нет!')" value="Отправить" name=send&gt;&lt;/td&gt;
    &lt;/tr&gt;
   &lt;/table&gt;
  &lt;/form&gt;



&lt;script language="JavaScript"&gt; 
var f=document.mainForm; 
function changeButtonStatus(){ 
f.send.disabled=(f.name.value && f.surname.value && f.phone.value) ? false : true; 
} 
changeButtonStatus(); 
&lt;/script&gt; 
</b>
</td>
</tr>
</table>

</code></pre>
	
<h1 align="center">Задача №2</h1>

<h3>Описание</h3>
  <p>UML – это унифицированный графический язык моделирования для описания, визуализации, проектирования и документирования ОО систем. UML призван поддерживать процесс моделирования ПС на основе ОО подхода, организовывать взаимосвязь концептуальных и программных понятий, отражать проблемы масштабирования сложных систем. Модели на UML используются на всех этапах жизненного цикла ПС, начиная с бизнес-анализа и заканчивая сопровождением системы. Разные организации могут применять UML по своему усмотрению в зависимости от своих проблемных областей и используемых технологий.</p>
  
<h3>Использование</h3>
<p>Использование UML не ограничивается моделированием программного обеспечения. Его также используют для моделирования бизнес-процессов системного проектирования и отображения организационных структур.
UML позволяет также разработчикам программного обеспечения достигнуть соглашения в графических обозначениях для представления общих понятий (таких как класс, компонент, обобщение (generalization), объединение (aggregation) и поведение, и больше сконцентрироваться на проектировании и архитектуре.</p>
  
	<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
	
	
<script type="text/javascript">
$(document).ready(function(){
 $('.spoiler_links').click(function(){
  $(this).parent().children('div.spoiler_body').toggle('normal');
  return false;
 });
});
</script>
	
<style type="text/css">
 .spoiler_body {display:none;background-color:#f1f1f1;height:100px;width:200px;}
 .spoiler_links {cursor:pointer;}
</style>
	
<h3>В UML предусмотрены следующие диаграммы:</h3>

<ol>
<li>Диаграммы, описывающие поведение системы:</li>
	<body>
<div>
 <h4><li>Диаграммы состояний (State diagrams),</li></h4><a href="" class="spoiler_links">показать / скрыть</a>
<div class="spoiler_body">
<dd>Диаграмма состояний — это, по существу, диаграмма состояний из теории автоматов со стандартизированными условными обозначениями, которая может определять множество систем от компьютерных программ до бизнес-процессов. Используются следующие условные обозначения:
<p>Круг, обозначающий начальное состояние.</p>
<p>Окружность с маленьким кругом внутри, обозначающая конечное состояние (если есть).</p>
<p>Скруглённый прямоугольник, обозначающий состояние. Верхушка прямоугольника содержит название состояния. В середине может быть горизонтальная линия, под которой записываются активности, происходящие в данном состоянии.</p>
<p>Стрелка, обозначающая переход. Название события (если есть), вызывающего переход, отмечается рядом со стрелкой. Охраняющее выражение может быть добавлено перед «/» и заключено в квадратные скобки (название_события[охраняющее_выражение]), что значит, что это выражение должно быть истинным, чтобы переход имел место. Если при переходе производится какое-то действие, то оно добавляется после «/» (название_события[охраняющее_выражение]/действие).</p>
<p>Толстая горизонтальная линия с либо множеством входящих линий и одной выходящей, либо одной входящей линией и множеством выходящих. Это обозначает объединение и разветвление соответственно.</p>
Пример:
<p><img src="UML_state_diagram.png"/></p></dd>
	</div>
	</div>

<div class="spoiler_body">
<h4><li>Диаграммы деятельностей (Activity diagrams),</li></h4>
<dd>Диаграммы деятельностей(англ. activity diagram) — UML-диаграмма, на которой показано разложение некоторой деятельности на её составные части. Под деятельностью (англ. activity) понимается спецификация исполняемого поведения в виде координированного последовательного и параллельного выполнения подчинённых элементов — вложенных видов деятельности и отдельных действий англ. action, соединённых между собой потоками, которые идут от выходов одного узла ко входам другого.
Диаграммы деятельности используются при моделировании бизнес-процессов, технологических процессов, последовательных и параллельных вычислений.
Диаграммы деятельности состоят из ограниченного количества фигур, соединённых стрелками. Основные фигуры:
<p>Прямоугольники с закруглениями — действия</p>
<p>Ромбы — решения</p>
<p>Широкие полосы — начало (разветвление) и окончание (схождение) ветвления действий</p>
<p>Чёрный круг — начало процесса (начальный узел)</p>
<p>Чёрный круг с обводкой — окончание процесса (финальный узел)</p>
<p>Стрелки идут от начала к концу процесса и показывают потоки управления или потоки объектов (данных).</p>
Пример:
<p><img src="Activity_conducting.svg.png"/></p>
</dd>
</div>
<div class="spoiler_body">
<h4><li>Диаграммы объектов (Object diagrams),</li></h4>
<dd>Диаграмма объектов (object diagram) – это снимок объектов системы в какой-то момент времени. Поскольку она показывает экземпляры, а не классы, то диаграмму объектов часто называют диаграммой экземпляров.
<p>Диаграмму объектов можно использовать для отображения одного из вариантов конфигурации объектов. (На рис. 6.1 показано множество классов, а на рис. 6.2 представлено множество связанных объектов.) Последний вариант очень полезен, когда допустимые связи между объектами могут быть сложными.</p>
<p>Можно определить, что элементы, показанные на рис. 6.2, являются экземплярами, поскольку их имена подчеркнуты. Каждое имя представляется в виде: имя экземпляра : имя класса. Обе части имени не являются обязательными, поэтому имена John, : Person и aPerson являются допустимыми. Если указано только имя класса, то необходимо поставить двоеточие. Можно также задать значения и атрибуты, как показано на рис. 6.2.</p>
<p>Строго говоря, элементы диаграммы объектов – это спецификации экземпляров, а не сами экземпляры. Причина в том, что разрешается оставлять обязательные атрибуты пустыми или показывать спецификации экземпляров абстрактных классов. Можно рассматривать спецификации экземпляров (instance specifications) как частично определенные экземпляры.</p>
Пример:
<p><img src="UML_fauler_image081.jpg"/> <img src="UML_fauler_image083.jpg"/> </p>
</dd>
</div>
<div class="spoiler_body">
<h4><li>Диаграммы последовательностей (Sequence diagrams),</li></h4>
<dd>Диаграмма последовательности (англ. sequence diagram) — диаграмма, на которой для некоторого набора объектов на единой временной оси показан жизненный цикл какого-либо определённого объекта (создание-деятельность-уничтожение некой сущности) и взаимодействие актёров (действующих лиц) ИС в рамках какого-либо определённого прецедента (отправка запросов и получение ответов). Используется в языке UML.
<p>Основными элементами диаграммы последовательности являются обозначения объектов (прямоугольники с названиями объектов), вертикальные «линии жизни» (англ. lifeline), отображающие течение времени, прямоугольники, отражающие деятельность объекта или исполнение им определенной функции (прямоугольники на пунктирной «линии жизни»), и стрелки, показывающие обмен сигналами или сообщениями между объектами.</p>
На данной диаграмме объекты располагаются слева направо.
<p>Пример:</p>
<p><img src="440px-CheckEmail.svg.png"/></p>
</dd>
</div>
<div class="spoiler_body">
<h4><li>Диаграммы кооперации (collaboration diagram);</li></h4>
<dd>Диаграммы кооперации - отображают поток событий через конкретный сценарий варианта использования, упорядочены по времени, а кооперативные диаграммы больше внимания заостряют на связях между объектами.
<p>На диаграмме кооперации представлена вся та информация, которая есть и на диаграмме последовательности, но кооперативная диаграмма по-другому описывает поток событий. Из нее легче понять связи между объектами, однако, труднее уяснить последовательность событий.</p>
<p>На кооперативной диаграмме так же, как и на диаграмме последовательности, стрелки обозначают сообщения, обмен которыми осуществляется в рамках данного варианта использования. Их временная последовательность указывается путем нумерации сообщений.</p>
Пример:
<p><img src="image009.gif"/></p>
</dd>
</div>
</ul>


<h4><li>Диаграммы, описывающие физическую реализацию системы:</li></h4>
<ul>
<div class="spoiler_body">
<h4><li>Диаграммы компонентов (Component diagrams);</li></h4>
<dd>Диаграммы компонентов (Component diagrams) - статическая структурная диаграмма, показывает разбиение программной системы на структурные компоненты и связи (зависимости) между компонентами. В качестве физических компонентов могут выступать файлы, библиотеки, модули, исполняемые файлы, пакеты и т. п.
<p>Основные сведнения:</p>
Компоненты связываются через зависимости, когда соединяется требуемый интерфейс одного компонента с имеющимся интерфейсом другого компонента. Таким образом иллюстрируются отношения клиент-источник между двумя компонентами.
Зависимость показывает, что один компонент предоставляет сервис, необходимый другому компоненту. Зависимость изображается стрелкой от интерфейса или порта клиента к импортируемому интерфейсу.
Когда диаграмма компонентов используется, чтобы показать внутреннюю структуру компонентов, предоставляемый и требуемый интерфейсы составного компонента могут делегироваться в соответствующие интерфейсы внутренних компонентов.
Делегация показывается связь внешнего контракта компонента с внутренней реализацией этого поведения внутренними компонентами.
<p>Пример:</p>
<p><img src="Policy_Admin_Component_Diagram.PNG"/></p>
</dd>
</div>
<div class="spoiler_body">
<h4><li>Диаграммы развертывания (Deployment diagrams).</li></h4>
<dd>Диаграммы развертывания (Deployment diagrams) - в UML моделирует физическое развертывание артефактов на узлах.[1] Например, чтобы описать веб-сайт диаграмма развертывания должна показывать, какие аппаратные компоненты («узлы») существуют (например, веб-сервер, сервер базы данных, сервер приложения), какие программные компоненты («артефакты») работают на каждом узле (например, веб-приложение, база данных), и как различные части этого комплекса соединяются друг с другом (например, JDBC, REST, RMI).
<p>Узлы представляются как прямоугольные параллелепипеды с артефактами, расположенными в них, изображенными в виде прямоугольников. Узлы могут иметь подузлы, которые представляются как вложенные прямоугольные параллелепипеды. Один узел диаграммы развертывания может концептуально представлять множество физических узлов, таких как кластер серверов баз данных.</p>
Существует два типа узлов:
<p>Узел устройства</p>
<p>Узел среды выполнения</p>
Узлы устройств — это физические вычислительные ресурсы со своей памятью и сервисами для выполнения программного обеспечения, такие как обычные ПК, мобильные телефоны. Узел среды выполнения — это программный вычислительный ресурс, который работает внутри внешнего узла и который предоставляет собой сервис, выполняющий другие исполняемые программные элементы.
<p>Пример:</p>
<p><img src="1024px-Deployment_Diagram.PNG"/></p>
</dd>
</div>
</ul>
</ol>

<div style="float:left"> 
 <h3 align="center">UML-диаграмма для задачи №1</h3>    
	<p><img src="uml.png" width="800" height="700" /> </p>



	<br>
	<br>
	<br>
	<br>
	<br>
	<h2>SPA</h2>


<canvas id="canvas" width="400" height="400"
style="background-color:#fba0e3">
</canvas>

<script>
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var radius = canvas.height / 2;
ctx.translate(radius, radius);
radius = radius * 0.90
setInterval(drawClock, 1000);
function drawClock() {
  drawFace(ctx, radius);
  drawNumbers(ctx, radius);
  drawTime(ctx, radius);
}
function drawFace(ctx, radius) {
  var grad;
  ctx.beginPath();
  ctx.arc(0, 0, radius, 0, 2*Math.PI);
  ctx.fillStyle = 'white';
  ctx.fill();
  grad = ctx.createRadialGradient(0,0,radius*0.95, 0,0,radius*1.05);
  grad.addColorStop(0, 'red');
  grad.addColorStop(0.5, 'white');
  grad.addColorStop(1, 'black');
  ctx.strokeStyle = grad;
  ctx.lineWidth = radius*0.1;
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(0, 0, radius*0.1, 0, 2*Math.PI);
  ctx.fillStyle = 'black';
  ctx.fill();
}
function drawNumbers(ctx, radius) {
  var ang;
  var num;
  ctx.font = radius*0.15 + "px arial";
  ctx.textBaseline="middle";
  ctx.textAlign="center";
  for(num = 1; num < 13; num++){
    ang = num * Math.PI / 6;
    ctx.rotate(ang);
    ctx.translate(0, -radius*0.85);
    ctx.rotate(-ang);
    ctx.fillText(num.toString(), 0, 0);
    ctx.rotate(ang);
    ctx.translate(0, radius*0.85);
    ctx.rotate(-ang);
  }
}
function drawTime(ctx, radius){
    var now = new Date();
    var hour = now.getHours();
    var minute = now.getMinutes();
    var second = now.getSeconds();
    //hour
    hour=hour%12;
    hour=(hour*Math.PI/6)+
    (minute*Math.PI/(6*60))+
    (second*Math.PI/(360*60));
    drawHand(ctx, hour, radius*0.5, radius*0.07);
    //minute
    minute=(minute*Math.PI/30)+(second*Math.PI/(30*60));
    drawHand(ctx, minute, radius*0.8, radius*0.07);
    // second
    second=(second*Math.PI/30);
    drawHand(ctx, second, radius*0.9, radius*0.02);
}
function drawHand(ctx, pos, length, width) {
    ctx.beginPath();
    ctx.lineWidth = width;
    ctx.lineCap = "round";
    ctx.moveTo(0,0);
    ctx.rotate(pos);
    ctx.lineTo(0, -length);
    ctx.stroke();
    ctx.rotate(-pos);
}
</script>

</div>

</body>

</html>
